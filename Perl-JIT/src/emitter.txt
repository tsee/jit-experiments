define: DEFINITE_TYPES TypeDouble|TypeInt|TypeUnsignedInt|TypeAny
define: ARITH_BINOPS   pj_binop_add|pj_binop_multiply
define: LOGICAL_BINOPS pj_binop_bool_and|pj_binop_bool_or
define: UNOPS          pj_unop_perl_int|pj_unop_negate

name: Expr
match: DOUBLE_Expr
match: INT_Expr

name: INT_Expr
match: UINT_Expr

name: RootExpr
match: Expr

name: RootExpr
match: Optree
emit_llvm: {
  $$ = _jit_emit_root_optree(state);
}

name: RootExpr
match: OPAQUE_Expr
emit_llvm: {
  $$ = EmitValue(OPTREE, &SCALAR_T);
}

name: Expr
match: Optree
emit_llvm: {
  $$ = _jit_emit_optree(state);
}

# Statements

name: Expr
match: AstStatement(Expr @ $E) @ $OP
weight: 2
delay: $E
emit_llvm: {
  $$ = _jit_emit_statement((Statement *) $OP.term, __($E));
}

name: Expr
match: AstStatement(Optree @ $O)
weight: 1
delay: $O
emit_llvm: {
  $$ = _jit_emit_root_optree(__($O));
}

# Constants

name: RootExpr
match: AstConst(DEFINITE_TYPES)
emit_llvm: {
  $$ = EmitValue(OPTREE, &SCALAR_T);
}

name: DOUBLE_Expr
match: AstConst(TypeDouble) @ $OP
emit_llvm: {
  $$ = _jit_emit_const((Constant *) $OP.term, &DOUBLE_T);
}

name: INT_Expr
match: AstConst(TypeInt) @ $OP
emit_llvm: {
  $$ = _jit_emit_const((Constant *) $OP.term, &INT_T);
}

name: UINT_Expr
match: AstConst(TypeUnsignedInt) @ $OP
emit_llvm: {
  $$ = _jit_emit_const((Constant *) $OP.term, &UNSIGNED_INT_T);
}

# Lexicals

name: RootExpr
match: AstLexical(DEFINITE_TYPES)
match: AstLexicalDeclaration(DEFINITE_TYPES)
emit_llvm: {
  $$ = EmitValue(OPTREE, &SCALAR_T);
}

name: DOUBLE_Expr
match: AstLexical(TypeDouble) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_sv((Lexical *) $OP.term);
}

name: DOUBLE_Expr
match: AstLexicalDeclaration(TypeDouble) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_declaration_sv((VariableDeclaration *) $OP.term);
}

name: INT_Expr
match: AstLexical(TypeInt) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_sv((Lexical *) $OP.term);
}

name: INT_Expr
match: AstLexicalDeclaration(TypeInt) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_declaration_sv((VariableDeclaration *) $OP.term);
}

name: OPAQUE_Expr
match: AstLexical(TypeOpaque)
match: AstLexicalDeclaration(TypeOpaque)

name: Expr
match: AstLexical(TypeAny) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_sv((Lexical *) $OP.term);
}

name: Expr
match: AstLexicalDeclaration(TypeAny) @ $OP
emit_llvm: {
  $$ = _jit_get_lexical_declaration_sv((VariableDeclaration *) $OP.term);
}

# Arithmetic unary

name: INT_Expr
match: AstUnop(UNOPS, DOUBLE_Expr @ $A) @ $OP
emit_llvm: {
  $$ = _jit_emit_unop((Unop *) $OP.term, _($A), &DOUBLE_T);
}

name: UNSIGNED_INT_Expr
match: AstUnop(UNOPS, INT_Expr @ $A) @ $OP
emit_llvm: {
  $$ = EmitValue(_($A).value, &UNSIGNED_INT_T);
}

name: OPAQUE_Expr
match: AstUnop(UNOPS, OPAQUE_Expr)

# TODO questionable
name: Expr
match: AstUnop(UNOPS, Expr @ $A) @ $OP
emit_llvm: {
  $$ = _jit_emit_unop((Unop *) $OP.term, _($A), &DOUBLE_T);
}

# Arithmetic binary

name: DOUBLE_Expr
match: AstBinop(ARITH_BINOPS, DOUBLE_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(ARITH_BINOPS, Expr @ $A, DOUBLE_Expr @ $B) @ $OP
emit_llvm: {
  $$ = _jit_emit_binop((Binop *) $OP.term, _($A), _($B), &DOUBLE_T);
}

name: INT_Expr
match: AstBinop(ARITH_BINOPS, INT_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(ARITH_BINOPS, Expr @ $A, INT_Expr @ $B) @ $OP
emit_llvm: {
  $$ = _jit_emit_binop((Binop *) $OP.term, _($A), _($B), &INT_T);
}

name: OPAQUE_Expr
match: AstBinop(ARITH_BINOPS, OPAQUE_Expr, Expr)
match: AstBinop(ARITH_BINOPS, Expr, OPAQUE_Expr)
match: AstBinop(ARITH_BINOPS, OPAQUE_Expr, OPAQUE_Expr)

# TODO questionable
name: Expr
match: AstBinop(ARITH_BINOPS, Expr @ $A, Expr @ $B) @ $OP
emit_llvm: {
  $$ = _jit_emit_binop((Binop *) $OP.term, _($A), _($B), &DOUBLE_T);
}

# Logical binary

name: DOUBLE_Expr
match: AstBinop(LOGICAL_BINOPS, DOUBLE_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(LOGICAL_BINOPS, Expr @ $A, DOUBLE_Expr @ $B) @ $OP
delay: $A, $B
emit_llvm: {
  $$ = _jit_emit_logop((Binop *) $OP.term, __($A), __($B), &DOUBLE_T);
}

name: INT_Expr
match: AstBinop(LOGICAL_BINOPS, INT_Expr @ $A, Expr @ $B) @ $OP
match: AstBinop(LOGICAL_BINOPS, Expr @ $A, INT_Expr @ $B) @ $OP
delay: $A, $B
emit_llvm: {
  $$ = _jit_emit_logop((Binop *) $OP.term, __($A), __($B), &INT_T);
}

name: OPAQUE_Expr
match: AstBinop(LOGICAL_BINOPS, OPAQUE_Expr, Expr)
match: AstBinop(LOGICAL_BINOPS, Expr, OPAQUE_Expr)
match: AstBinop(LOGICAL_BINOPS, OPAQUE_Expr, OPAQUE_Expr)

name: Expr
match: AstBinop(LOGICAL_BINOPS, Expr @ $A, Expr @ $B) @ $OP
delay: $A, $B
emit_llvm: {
  $$ = _jit_emit_logop((Binop *) $OP.term, __($A), __($B), &SCALAR_T);
}
